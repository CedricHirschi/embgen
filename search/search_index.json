{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"embgen","text":"<p>embgen is a unified code generator for embedded systems that generates code from YAML definitions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Plugin-based architecture \u2014 Add new domains by creating a single directory</li> <li>Auto-discovery \u2014 CLI automatically discovers available domains</li> <li>Auto-detection \u2014 Automatically detect domain from YAML content</li> <li>Multiple output formats \u2014 Generate C headers, Python, Markdown documentation, and more</li> <li>Template-based \u2014 Uses Jinja2 templates for flexible output customization</li> <li>Extensible \u2014 Create custom domains for your specific code generation needs</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Using uv (recommended)\nuv sync\n\n# Or with pip\npip install -e .\n</code></pre>"},{"location":"#generate-code","title":"Generate Code","text":"<pre><code># Generate C header from a commands definition\nembgen commands config.yml -o output/ --h\n\n# Generate multiple formats at once\nembgen commands config.yml -o output/ --h --py --md\n\n# Auto-detect the domain type\nembgen auto config.yml -o output/ --h\n</code></pre>"},{"location":"#built-in-domains","title":"Built-in Domains","text":"<p>embgen ships with two built-in domains:</p> Domain Description Output Formats Commands Command protocol definitions C Header, Python, Markdown Registers Hardware register maps C Header, Python, Markdown"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>CLI Usage \u2014 Complete command-line reference</li> <li>Python API \u2014 Using embgen as a library</li> <li>Built-in Domains \u2014 Commands and Registers documentation</li> <li>Creating Domains \u2014 How to create custom domains</li> <li>Architecture \u2014 Internal design and module structure</li> </ul>"},{"location":"architecture/","title":"embgen Architecture","text":"<p>This document describes the architecture and module structure of the embgen package.</p>"},{"location":"architecture/#package-overview","title":"Package Overview","text":"<pre><code>flowchart TB\n    subgraph User[\"User Interaction\"]\n        CLI[\"CLI&lt;br/&gt;(cli.py)\"]\n        YAML[\"YAML Config&lt;br/&gt;(*.yml)\"]\n    end\n\n    subgraph Core[\"Core Generation\"]\n        CG[\"CodeGenerator&lt;br/&gt;(generator.py)\"]\n        Templates[\"Template Utilities&lt;br/&gt;(templates.py)\"]\n    end\n\n    subgraph Discovery[\"Discovery System\"]\n        Disc[\"discover_domains()&lt;br/&gt;(discovery.py)\"]\n        Detect[\"detect_domain()&lt;br/&gt;(discovery.py)\"]\n    end\n\n    subgraph Models[\"Data Models\"]\n        BaseConfig[\"BaseConfig&lt;br/&gt;(Pydantic)\"]\n        Enum[\"Enum&lt;br/&gt;(Pydantic)\"]\n        TI[\"TemplateInfo&lt;br/&gt;(dataclass)\"]\n        MG[\"MultifileGroup&lt;br/&gt;(dataclass)\"]\n    end\n\n    subgraph Domains[\"Domain Generators\"]\n        DG[\"DomainGenerator ABC&lt;br/&gt;(domains/__init__.py)\"]\n        CMD[\"CommandsGenerator&lt;br/&gt;(domains/commands/)\"]\n        REG[\"RegistersGenerator&lt;br/&gt;(domains/registers/)\"]\n        User_Domain[\"User Domains&lt;br/&gt;(EMBGEN_DOMAINS_DIR)\"]\n    end\n\n    subgraph Output[\"Generated Files\"]\n        Header[\"*.h\"]\n        Python[\"*.py\"]\n        Markdown[\"*.md\"]\n        Other[\"Other formats\"]\n    end\n\n    CLI --&gt; |\"1. Parse args\"| Disc\n    CLI --&gt; |\"2. Load YAML\"| YAML\n    Disc --&gt; |\"Find domains\"| DG\n    DG --&gt; CMD\n    DG --&gt; REG\n    DG --&gt; User_Domain\n    CLI --&gt; |\"3. Create\"| CG\n    CG --&gt; |\"4. Parse YAML\"| YAML\n    CG --&gt; |\"5. Validate\"| DG\n    CG --&gt; |\"6. Render\"| Templates\n    Templates --&gt; |\"Jinja2\"| Output\n    CG --&gt; |\"7. Post-generate\"| DG</code></pre>"},{"location":"architecture/#module-responsibilities","title":"Module Responsibilities","text":"<pre><code>classDiagram\n    class cli {\n        +main()\n        +add_template_flags()\n        +build_parser()\n    }\n\n    class discovery {\n        +BUILTIN_DOMAINS_PATH\n        +EMBGEN_DOMAINS_DIR_ENV\n        +discover_domains()\n        +detect_domain()\n    }\n\n    class generator {\n        +CodeGenerator\n    }\n\n    class templates {\n        +FILE_TYPES\n        +file_type()\n        +get_env()\n        +parse_template_name()\n        +discover_templates()\n    }\n\n    class models {\n        +BaseConfig\n        +Enum\n        +TemplateInfo\n        +MultifileGroup\n    }\n\n    class scaffold {\n        +scaffold_domain()\n    }\n\n    class DomainGenerator {\n        &lt;&lt;abstract&gt;&gt;\n        +name: str\n        +description: str\n        +templates_path: Path\n        +detect(data) bool\n        +validate(data) BaseConfig\n        +render(config, template) str\n        +post_generate()\n    }\n\n    class CodeGenerator {\n        +generator: DomainGenerator\n        +output_path: Path\n        +env: Environment\n        +parse_yaml(path) dict\n        +validate(data) BaseConfig\n        +ensure_output_dir() Path\n        +render_to_file()\n        +render_multifile_group()\n        +generate()\n        +generate_from_file()\n    }\n\n    cli --&gt; discovery : imports\n    cli --&gt; generator : uses\n    cli --&gt; templates : uses\n    cli --&gt; scaffold : uses\n    generator --&gt; DomainGenerator : uses\n    generator --&gt; templates : uses\n    generator --&gt; models : uses\n    DomainGenerator --&gt; models : extends BaseConfig</code></pre>"},{"location":"architecture/#generation-flow","title":"Generation Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI as cli.py\n    participant Disc as discovery.py\n    participant Gen as CodeGenerator\n    participant Domain as DomainGenerator\n    participant Tmpl as templates.py\n    participant FS as File System\n\n    User-&gt;&gt;CLI: embgen commands config.yml -h -p\n    CLI-&gt;&gt;Disc: discover_domains()\n    Disc--&gt;&gt;CLI: {commands: CommandsGen, registers: RegistersGen}\n    CLI-&gt;&gt;Disc: detect_domain(yaml_data) [if auto-detect]\n    CLI-&gt;&gt;Gen: new CodeGenerator(domain, output_path)\n    CLI-&gt;&gt;Gen: generate_from_file(config.yml, templates)\n    Gen-&gt;&gt;FS: parse YAML file\n    Gen-&gt;&gt;Domain: validate(data)\n    Domain--&gt;&gt;Gen: CommandsConfig\n    Gen-&gt;&gt;Gen: ensure_output_dir()\n\n    loop For each template\n        Gen-&gt;&gt;Domain: render(config, template)\n        Domain-&gt;&gt;Tmpl: Jinja2 rendering\n        Tmpl--&gt;&gt;Domain: rendered content\n        Domain--&gt;&gt;Gen: content string\n        Gen-&gt;&gt;FS: write output file\n    end\n\n    Gen-&gt;&gt;Domain: post_generate(output_path, generated_exts)\n    Domain-&gt;&gt;FS: copy extra files (e.g., commands_base.py)\n    Gen--&gt;&gt;CLI: list of generated filenames\n    CLI--&gt;&gt;User: Success message</code></pre>"},{"location":"architecture/#domain-structure","title":"Domain Structure","text":"<pre><code>graph LR\n    subgraph BuiltIn[\"Built-in Domains\"]\n        subgraph Commands[\"domains/commands/\"]\n            CMD_Init[\"__init__.py\"]\n            CMD_Gen[\"generator.py\"]\n            CMD_Mod[\"models.py\"]\n            CMD_Tmpl[\"templates/\"]\n        end\n\n        subgraph Registers[\"domains/registers/\"]\n            REG_Init[\"__init__.py\"]\n            REG_Gen[\"generator.py\"]\n            REG_Mod[\"models.py\"]\n            REG_Tmpl[\"templates/\"]\n        end\n    end\n\n    subgraph UserDomains[\"User Domains (optional)\"]\n        USR_Dir[\"EMBGEN_DOMAINS_DIR/\"]\n        USR_Custom[\"custom_domain/\"]\n    end\n\n    Discovery[\"discovery.py\"]\n\n    Discovery --&gt;|\"scan\"| BuiltIn\n    Discovery --&gt;|\"scan (override)\"| UserDomains</code></pre>"},{"location":"architecture/#multifile-template-support","title":"Multifile Template Support","text":"<pre><code>flowchart LR\n    subgraph Templates[\"Template Files\"]\n        Single[\"template.h.j2&lt;br/&gt;template.py.j2\"]\n        Multi[\"template.c_multi.h.j2&lt;br/&gt;template.c_multi.c.j2\"]\n        MultiSuffix[\"template.sv_multi.sv.1.j2&lt;br/&gt;template.sv_multi.sv.2.j2\"]\n    end\n\n    subgraph Parsing[\"parse_template_name()\"]\n        Parse1[\"(None, 'h', None)\"]\n        Parse2[\"('c', 'h', None)&lt;br/&gt;('c', 'c', None)\"]\n        Parse3[\"('sv', 'sv', '1')&lt;br/&gt;('sv', 'sv', '2')\"]\n    end\n\n    subgraph Output[\"Generated Files\"]\n        Out1[\"config.h\"]\n        Out2[\"config.h&lt;br/&gt;config.c\"]\n        Out3[\"config_1.sv&lt;br/&gt;config_2.sv\"]\n    end\n\n    Single --&gt; Parse1 --&gt; Out1\n    Multi --&gt; Parse2 --&gt; Out2\n    MultiSuffix --&gt; Parse3 --&gt; Out3</code></pre>"},{"location":"architecture/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li> <p>Abstract Factory: <code>DomainGenerator</code> ABC defines the interface, concrete implementations (CommandsGenerator, RegistersGenerator) are discovered dynamically.</p> </li> <li> <p>Strategy Pattern: Each domain implements its own validation and rendering strategy.</p> </li> <li> <p>Plugin Architecture: User domains can be added via <code>EMBGEN_DOMAINS_DIR</code> environment variable without modifying core code.</p> </li> <li> <p>Separation of Concerns:</p> </li> <li><code>discovery.py</code>: Finding and loading domains</li> <li><code>generator.py</code>: Orchestrating the generation workflow</li> <li><code>templates.py</code>: Template utilities and parsing</li> <li><code>models.py</code>: Shared data structures</li> <li><code>cli.py</code>: Command-line interface only</li> </ol>"},{"location":"domains/","title":"Built-in Domains","text":"<p>embgen includes two built-in domains for common embedded systems code generation tasks:</p>"},{"location":"domains/#commands","title":"Commands","text":"<p>Generate code from command protocol definitions. Perfect for:</p> <ul> <li>Embedded communication protocols</li> <li>Serial command interfaces  </li> <li>RPC-style APIs between host and device</li> <li>Test automation interfaces</li> </ul> <p>Output Formats:</p> <ul> <li>C Header \u2014 Command IDs, argument structures, enumerations</li> <li>Python \u2014 Dataclasses with serialization/deserialization</li> <li>Markdown \u2014 Human-readable documentation</li> </ul>"},{"location":"domains/#registers","title":"Registers","text":"<p>Generate code from hardware register map definitions. Perfect for:</p> <ul> <li>MCU peripheral drivers</li> <li>FPGA register interfaces</li> <li>Hardware abstraction layers</li> <li>Register documentation</li> </ul> <p>Output Formats:</p> <ul> <li>C Header \u2014 Addresses, bitfield macros, accessor functions</li> <li>Python \u2014 Register classes with bit manipulation</li> <li>Markdown \u2014 Documentation with bit-level layouts</li> </ul>"},{"location":"domains/#domain-detection","title":"Domain Detection","text":"<p>When using <code>embgen auto</code>, the domain is detected by examining the YAML structure:</p> YAML Key Detected Domain <code>commands</code> Commands <code>regmap</code> Registers <pre><code># Detected as Commands domain\nname: MyCommands\ncommands:\n  - name: ping\n    id: 0\n\n# Detected as Registers domain  \nname: MyRegisters\nregmap:\n  - name: CONTROL\n    address: 0x00\n</code></pre>"},{"location":"domains/commands/","title":"Commands Domain","text":"<p>The Commands domain generates code from command protocol definitions, typically used for embedded communication protocols.</p>"},{"location":"domains/commands/#yaml-schema","title":"YAML Schema","text":"<pre><code>name: string              # Required: Name for the command set\nfile: string              # Optional: Output filename (defaults to lowercase name)\nendianness: \"&lt;\" | \"&gt;\"     # Optional: Little or big endian (default: \"&lt;\")\ncommands:                 # Required: List of commands\n  - name: string          # Command name\n    id: integer           # Unique command ID\n    description: string   # Optional: Human-readable description\n    args:                 # Optional: List of arguments\n      - name: string\n        type: string      # Argument type (see below)\n        description: string\n        default: value    # Optional: Default value\n        enums:            # Optional: Enumeration values\n          - name: string\n            value: integer\n            description: string\n    returns:              # Optional: Return values (same format as args)\n      - name: string\n        type: string\n        description: string\n</code></pre>"},{"location":"domains/commands/#argument-types","title":"Argument Types","text":"Type Description Python Type <code>B</code> Unsigned 8-bit integer <code>int</code> <code>H</code> Unsigned 16-bit integer <code>int</code> <code>I</code> Unsigned 32-bit integer <code>int</code> <code>Q</code> Unsigned 64-bit integer <code>int</code> <code>b</code> Signed 8-bit integer <code>int</code> <code>h</code> Signed 16-bit integer <code>int</code> <code>i</code> Signed 32-bit integer <code>int</code> <code>q</code> Signed 64-bit integer <code>int</code> <code>e</code> 16-bit float <code>float</code> <code>f</code> 32-bit float <code>float</code> <code>d</code> 64-bit float <code>float</code> <code>?</code> Boolean <code>bool</code> <code>s</code> Byte string <code>bytes</code> <p>These type codes follow Python's <code>struct</code> module conventions.</p>"},{"location":"domains/commands/#example-configuration","title":"Example Configuration","text":"<pre><code>name: TinyProbeCommands\nfile: commands\nendianness: \"&lt;\"\n\ncommands:\n  - name: ping\n    id: 0\n    description: \"Ping the device\"\n    args:\n      - name: probe_id\n        type: B\n        default: 1\n        description: \"ID of the probe to ping\"\n\n  - name: set_mode\n    id: 1\n    description: \"Set the operating mode\"\n    args:\n      - name: mode\n        type: B\n        description: \"Operating mode\"\n        enums:\n          - { name: IDLE, value: 0, description: \"Idle mode\" }\n          - { name: ACTIVE, value: 1, description: \"Active mode\" }\n          - { name: SLEEP, value: 2, description: \"Sleep mode\" }\n\n  - name: read_sensor\n    id: 2\n    description: \"Read sensor value\"\n    args:\n      - name: sensor_id\n        type: B\n        description: \"Sensor ID to read\"\n    returns:\n      - name: value\n        type: f\n        description: \"Sensor reading\"\n\n  - name: write_data\n    id: 3\n    description: \"Write raw data\"\n    args:\n      - name: data\n        type: s\n        description: \"Data bytes to write\"\n</code></pre>"},{"location":"domains/commands/#generated-outputs","title":"Generated Outputs","text":""},{"location":"domains/commands/#c-header---h","title":"C Header (<code>--h</code>)","text":"<pre><code>embgen commands config.yml -o output/ --h\n</code></pre> <p>Generates:</p> <ul> <li><code>commands.h</code> \u2014 Main header with:<ul> <li>Command ID enum</li> <li>Argument type enums</li> <li>Struct definitions for command arguments</li> </ul> </li> </ul> <pre><code>// commands.h - Generated by embgen\n#ifndef COMMANDS_H\n#define COMMANDS_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n// Command IDs\ntypedef enum {\n    CMD_PING = 0,\n    CMD_SET_MODE = 1,\n    CMD_READ_SENSOR = 2,\n    CMD_WRITE_DATA = 3,\n} CommandId;\n\n// Mode enumeration\ntypedef enum {\n    MODE_IDLE = 0,\n    MODE_ACTIVE = 1,\n    MODE_SLEEP = 2,\n} SetModeMode;\n\n// Command argument structures\ntypedef struct {\n    uint8_t probe_id;\n} PingArgs;\n\ntypedef struct {\n    SetModeMode mode;\n} SetModeArgs;\n\n// ... etc\n\n#endif // COMMANDS_H\n</code></pre>"},{"location":"domains/commands/#python-module---py","title":"Python Module (<code>--py</code>)","text":"<pre><code>embgen commands config.yml -o output/ --py\n</code></pre> <p>Generates:</p> <ul> <li><code>commands.py</code> \u2014 Command dataclasses with serialization</li> <li><code>commands_base.py</code> \u2014 Base classes for command handling</li> </ul> <pre><code># commands.py - Generated by embgen\nfrom dataclasses import dataclass\nfrom enum import IntEnum\nfrom commands_base import Command\n\nclass SetModeMode(IntEnum):\n    IDLE = 0\n    ACTIVE = 1\n    SLEEP = 2\n\n@dataclass\nclass Ping(Command):\n    probe_id: int = 1\n\n    ID = 0\n    FORMAT = \"&lt;B\"\n\n@dataclass  \nclass SetMode(Command):\n    mode: SetModeMode = SetModeMode.IDLE\n\n    ID = 1\n    FORMAT = \"&lt;B\"\n\n# ... etc\n</code></pre>"},{"location":"domains/commands/#markdown-documentation---md","title":"Markdown Documentation (<code>--md</code>)","text":"<pre><code>embgen commands config.yml -o output/ --md\n</code></pre> <p>Generates human-readable documentation with:</p> <ul> <li>Command table with IDs and descriptions</li> <li>Detailed argument documentation</li> <li>Enumeration value tables</li> </ul>"},{"location":"domains/commands/#cli-usage","title":"CLI Usage","text":"<pre><code># Generate C header only\nembgen commands config.yml -o output/ --h\n\n# Generate all formats\nembgen commands config.yml -o output/ --h --py --md\n\n# With debug output\nembgen -d commands config.yml -o output/ --h\n</code></pre>"},{"location":"domains/commands/#python-api-usage","title":"Python API Usage","text":"<pre><code>from pathlib import Path\nfrom embgen.discovery import discover_domains\nfrom embgen.generator import CodeGenerator\n\ndomains = discover_domains()\ncode_gen = CodeGenerator(domains[\"commands\"], Path(\"output\"))\n\ntemplates = {\"h\": \"template.h.j2\", \"py\": \"template.py.j2\"}\ncode_gen.generate_from_file(Path(\"commands.yml\"), templates)\n</code></pre>"},{"location":"domains/commands/#post-generation-files","title":"Post-Generation Files","text":"<p>When generating Python output (<code>--py</code>), the Commands domain automatically copies <code>commands_base.py</code> to the output directory. This file contains base classes for command serialization and deserialization.</p>"},{"location":"domains/registers/","title":"Registers Domain","text":"<p>The Registers domain generates code from hardware register map definitions, typically used for MCU peripherals, FPGA interfaces, or other memory-mapped hardware.</p>"},{"location":"domains/registers/#yaml-schema","title":"YAML Schema","text":"<pre><code>name: string              # Required: Name for the register map\nfile: string              # Optional: Output filename (defaults to lowercase name)\nregmap:                   # Required: List of registers\n  - name: string          # Register name\n    address: integer      # Register address (hex or decimal)\n    description: string   # Optional: Human-readable description\n    access: string        # Optional: Access type (default: \"rw\")\n    bitfields:            # Required: List of bitfields\n      - name: string\n        width: integer    # Bit width\n        offset: integer   # Bit offset from LSB\n        reset: integer    # Reset value\n        description: string\n        enums:            # Optional: Enumeration values\n          - name: string\n            value: integer\n            description: string\n</code></pre>"},{"location":"domains/registers/#access-types","title":"Access Types","text":"Type Description <code>rw</code> Read-write (default) <code>ro</code> Read-only <code>wo</code> Write-only <code>rw1c</code> Read-write, write-1-to-clear <code>wosc</code> Write-only, self-clearing <code>rolh</code> Read-only, latch high"},{"location":"domains/registers/#example-configuration","title":"Example Configuration","text":"<pre><code>name: SimpleRegmap\nfile: simple\n\nregmap:\n  - name: CONTROL\n    description: Control register\n    address: 0x00\n    access: rw\n    bitfields:\n      - name: ENABLE\n        description: Enable bit\n        width: 1\n        offset: 0\n        reset: 0\n      - name: MODE\n        description: Operating mode\n        width: 3\n        offset: 1\n        reset: 1\n        enums:\n          - { name: POWER_OFF, value: 0, description: \"Device is off\" }\n          - { name: NORMAL, value: 1, description: \"Normal operation\" }\n          - { name: STANDBY, value: 2, description: \"Standby mode\" }\n          - { name: SLEEP, value: 3, description: \"Sleep mode\" }\n      - name: RESET\n        description: Software reset\n        width: 1\n        offset: 4\n        reset: 0\n\n  - name: STATUS\n    description: Status register\n    address: 0x04\n    access: ro\n    bitfields:\n      - name: READY\n        description: Ready status\n        width: 1\n        offset: 0\n        reset: 1\n      - name: BUSY\n        description: Busy status\n        width: 1\n        offset: 1\n        reset: 0\n      - name: ERROR\n        description: Error flag\n        width: 1\n        offset: 2\n        reset: 0\n\n  - name: DATA\n    description: Data register\n    address: 0x08\n    bitfields:\n      - name: VALUE\n        description: Data value\n        width: 16\n        offset: 0\n        reset: 0\n</code></pre>"},{"location":"domains/registers/#generated-outputs","title":"Generated Outputs","text":""},{"location":"domains/registers/#c-header---h","title":"C Header (<code>--h</code>)","text":"<pre><code>embgen registers config.yml -o output/ --h\n</code></pre> <p>Generates:</p> <ul> <li><code>&lt;name&gt;.h</code> \u2014 Main header with:<ul> <li>Register addresses</li> <li>Bitfield masks and offsets</li> <li>Accessor macros</li> </ul> </li> <li><code>reg_common.h</code> \u2014 Common register utilities</li> <li><code>reg_common.c</code> \u2014 Common register functions</li> </ul> <pre><code>// simple.h - Generated by embgen\n#ifndef SIMPLE_H\n#define SIMPLE_H\n\n#include &lt;stdint.h&gt;\n#include \"reg_common.h\"\n\n// Register addresses\n#define REG_CONTROL_ADDR    0x00\n#define REG_STATUS_ADDR     0x04\n#define REG_DATA_ADDR       0x08\n\n// CONTROL register bitfields\n#define CONTROL_ENABLE_OFFSET   0\n#define CONTROL_ENABLE_MASK     0x00000001\n#define CONTROL_MODE_OFFSET     1\n#define CONTROL_MODE_MASK       0x0000000E\n#define CONTROL_RESET_OFFSET    4\n#define CONTROL_RESET_MASK      0x00000010\n\n// MODE enumeration\ntypedef enum {\n    CONTROL_MODE_POWER_OFF = 0,\n    CONTROL_MODE_NORMAL = 1,\n    CONTROL_MODE_STANDBY = 2,\n    CONTROL_MODE_SLEEP = 3,\n} ControlMode;\n\n// Accessor macros\n#define CONTROL_GET_ENABLE(reg) \\\n    (((reg) &amp; CONTROL_ENABLE_MASK) &gt;&gt; CONTROL_ENABLE_OFFSET)\n#define CONTROL_SET_ENABLE(reg, val) \\\n    (((reg) &amp; ~CONTROL_ENABLE_MASK) | (((val) &lt;&lt; CONTROL_ENABLE_OFFSET) &amp; CONTROL_ENABLE_MASK))\n\n// ... etc\n\n#endif // SIMPLE_H\n</code></pre>"},{"location":"domains/registers/#python-module---py","title":"Python Module (<code>--py</code>)","text":"<pre><code>embgen registers config.yml -o output/ --py\n</code></pre> <p>Generates Python classes with:</p> <ul> <li>Register classes with address constants</li> <li>Bitfield accessors as properties</li> <li>Enumeration classes</li> </ul> <pre><code># simple.py - Generated by embgen\nfrom dataclasses import dataclass\nfrom enum import IntEnum\n\nclass ControlMode(IntEnum):\n    POWER_OFF = 0\n    NORMAL = 1\n    STANDBY = 2\n    SLEEP = 3\n\n@dataclass\nclass ControlRegister:\n    ADDRESS = 0x00\n\n    value: int = 0\n\n    @property\n    def enable(self) -&gt; int:\n        return (self.value &gt;&gt; 0) &amp; 0x1\n\n    @enable.setter\n    def enable(self, val: int):\n        self.value = (self.value &amp; ~0x1) | ((val &amp; 0x1) &lt;&lt; 0)\n\n    @property\n    def mode(self) -&gt; ControlMode:\n        return ControlMode((self.value &gt;&gt; 1) &amp; 0x7)\n\n    @mode.setter\n    def mode(self, val: ControlMode):\n        self.value = (self.value &amp; ~0xE) | ((val &amp; 0x7) &lt;&lt; 1)\n\n# ... etc\n</code></pre>"},{"location":"domains/registers/#markdown-documentation---md","title":"Markdown Documentation (<code>--md</code>)","text":"<pre><code>embgen registers config.yml -o output/ --md\n</code></pre> <p>Generates documentation with:</p> <ul> <li>Register summary table</li> <li>Detailed bitfield layouts</li> <li>Visual bit diagrams</li> <li>Enumeration value tables</li> </ul>"},{"location":"domains/registers/#register-bit-layout-diagram","title":"Register Bit Layout Diagram","text":"<p>The Markdown output includes visual bit diagrams:</p> <pre><code>CONTROL (0x00) - Control register [RW]\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502 7  \u2502 6  \u2502 5  \u2502 4  \u2502 3  \u2502 2  \u2502 1  \u2502 0  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524\n\u2502   reserved   \u2502RST \u2502     MODE     \u2502 EN \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"domains/registers/#cli-usage","title":"CLI Usage","text":"<pre><code># Generate C header only\nembgen registers config.yml -o output/ --h\n\n# Generate all formats  \nembgen registers config.yml -o output/ --h --py --md\n\n# With debug output\nembgen -d registers config.yml -o output/ --h\n</code></pre>"},{"location":"domains/registers/#python-api-usage","title":"Python API Usage","text":"<pre><code>from pathlib import Path\nfrom embgen.discovery import discover_domains\nfrom embgen.generator import CodeGenerator\n\ndomains = discover_domains()\ncode_gen = CodeGenerator(domains[\"registers\"], Path(\"output\"))\n\ntemplates = {\"h\": \"template.h.j2\"}\ncode_gen.generate_from_file(Path(\"registers.yml\"), templates)\n</code></pre>"},{"location":"domains/registers/#post-generation-files","title":"Post-Generation Files","text":"<p>When generating C header output (<code>--h</code>), the Registers domain automatically copies these utility files:</p> <ul> <li><code>reg_common.h</code> \u2014 Common macros and type definitions</li> <li><code>reg_common.c</code> \u2014 Common register manipulation functions</li> </ul> <p>These files provide platform-independent register access utilities.</p>"},{"location":"extending/","title":"Extending embgen","text":"<p>embgen is designed to be easily extensible with custom domains. A domain is a self-contained package that:</p> <ul> <li>Defines a YAML schema for input configuration</li> <li>Provides Jinja2 templates for code generation</li> <li>Implements validation and rendering logic</li> </ul>"},{"location":"extending/#creating-a-new-domain","title":"Creating a New Domain","text":"<p>The quickest way to create a new domain is using the <code>embgen new</code> command:</p> <pre><code># Create in a custom directory\nembgen new myprotocol --location ./domains\n\n# Create as a built-in domain\nembgen new myprotocol --builtin\n</code></pre> <p>This scaffolds a complete domain with:</p> <pre><code>myprotocol/\n\u251c\u2500\u2500 __init__.py       # Domain entry point\n\u251c\u2500\u2500 generator.py      # Generator implementation\n\u251c\u2500\u2500 models.py         # Pydantic data models\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 template.h.j2   # C header template\n    \u251c\u2500\u2500 template.py.j2  # Python template\n    \u2514\u2500\u2500 template.md.j2  # Markdown template\n</code></pre>"},{"location":"extending/#domain-structure","title":"Domain Structure","text":""},{"location":"extending/#required-files","title":"Required Files","text":"File Purpose <code>__init__.py</code> Exports the generator instance <code>generator.py</code> Implements <code>DomainGenerator</code> ABC <code>models.py</code> Defines Pydantic validation models <code>templates/</code> Contains Jinja2 templates"},{"location":"extending/#entry-point-__init__py","title":"Entry Point (<code>__init__.py</code>)","text":"<p>The <code>__init__.py</code> must export a <code>generator</code> variable:</p> <pre><code>\"\"\"The myprotocol domain for embgen.\"\"\"\n\nfrom .generator import MyprotocolGenerator\n\ngenerator = MyprotocolGenerator()\n</code></pre>"},{"location":"extending/#topics","title":"Topics","text":"<ul> <li> <p> Writing Models</p> <p>Define Pydantic models for YAML validation</p> </li> <li> <p> Writing Generators</p> <p>Implement the DomainGenerator interface</p> </li> <li> <p> Writing Templates</p> <p>Create Jinja2 templates for output formats</p> </li> <li> <p> Multifile Templates</p> <p>Generate multiple files from a single template group</p> </li> </ul>"},{"location":"extending/generators/","title":"Writing Generators","text":"<p>Generators implement the <code>DomainGenerator</code> abstract base class and define how your domain processes YAML and renders templates.</p>"},{"location":"extending/generators/#domaingenerator-interface","title":"DomainGenerator Interface","text":"<pre><code>from abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Any\n\nfrom jinja2 import Template\n\nfrom embgen.models import BaseConfig\n\n\nclass DomainGenerator(ABC):\n    \"\"\"Abstract base class for domain generators.\"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Domain name for CLI subcommand.\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def description(self) -&gt; str:\n        \"\"\"Help text for CLI.\"\"\"\n        ...\n\n    @abstractmethod\n    def detect(self, data: dict[str, Any]) -&gt; bool:\n        \"\"\"Return True if this YAML belongs to this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def validate(self, data: dict[str, Any]) -&gt; BaseConfig:\n        \"\"\"Parse and validate YAML into a config object.\"\"\"\n        ...\n\n    @abstractmethod\n    def render(self, config: Any, template: Template) -&gt; str:\n        \"\"\"Render a config to a Jinja2 template.\"\"\"\n        ...\n\n    @property\n    def templates_path(self) -&gt; Path:\n        \"\"\"Path to this domain's templates directory.\"\"\"\n        ...\n\n    def post_generate(\n        self, config: BaseConfig, output: Path, generated_extensions: set[str]\n    ) -&gt; list[str]:\n        \"\"\"Hook called after templates are rendered.\"\"\"\n        ...\n</code></pre>"},{"location":"extending/generators/#implementing-a-generator","title":"Implementing a Generator","text":""},{"location":"extending/generators/#basic-implementation","title":"Basic Implementation","text":"<pre><code># generator.py\n\"\"\"Generator implementation for the protocol domain.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Any, cast\n\nfrom jinja2 import Template\n\nfrom embgen.domains import DomainGenerator\nfrom embgen.models import BaseConfig\nfrom .models import ProtocolConfig\n\n\nclass ProtocolGenerator(DomainGenerator):\n    \"\"\"Generator for protocol domain.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"protocol\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Generate code from protocol definitions\"\n\n    def detect(self, data: dict[str, Any]) -&gt; bool:\n        \"\"\"Detect if YAML belongs to this domain.\"\"\"\n        # Check for characteristic keys\n        return \"messages\" in data or data.get(\"domain\") == \"protocol\"\n\n    def validate(self, data: dict[str, Any]) -&gt; BaseConfig:\n        \"\"\"Parse and validate YAML into config.\"\"\"\n        return cast(BaseConfig, ProtocolConfig.model_validate(data))\n\n    def render(self, config: Any, template: Template) -&gt; str:\n        \"\"\"Render config to a template.\"\"\"\n        cfg = config if isinstance(config, ProtocolConfig) else ProtocolConfig.model_validate(config)\n        return template.render(config=cfg)\n\n    @property\n    def templates_path(self) -&gt; Path:\n        \"\"\"Path to templates directory.\"\"\"\n        return Path(__file__).parent / \"templates\"\n</code></pre>"},{"location":"extending/generators/#detection-logic","title":"Detection Logic","text":"<p>The <code>detect</code> method determines if a YAML file belongs to your domain. It's used by <code>embgen auto</code> for automatic domain detection.</p>"},{"location":"extending/generators/#simple-key-detection","title":"Simple Key Detection","text":"<pre><code>def detect(self, data: dict[str, Any]) -&gt; bool:\n    # Check for a required key\n    return \"messages\" in data\n</code></pre>"},{"location":"extending/generators/#multiple-key-detection","title":"Multiple Key Detection","text":"<pre><code>def detect(self, data: dict[str, Any]) -&gt; bool:\n    # Must have messages, optionally with specific structure\n    if \"messages\" not in data:\n        return False\n\n    # Check first message has expected structure\n    messages = data.get(\"messages\", [])\n    if messages and isinstance(messages[0], dict):\n        return \"id\" in messages[0] and \"fields\" in messages[0]\n\n    return False\n</code></pre>"},{"location":"extending/generators/#explicit-domain-key","title":"Explicit Domain Key","text":"<pre><code>def detect(self, data: dict[str, Any]) -&gt; bool:\n    # Support explicit domain declaration\n    if data.get(\"domain\") == \"protocol\":\n        return True\n\n    # Fall back to structure detection\n    return \"messages\" in data\n</code></pre>"},{"location":"extending/generators/#validation","title":"Validation","text":"<p>The <code>validate</code> method converts raw YAML data into a typed Pydantic model:</p> <pre><code>def validate(self, data: dict[str, Any]) -&gt; BaseConfig:\n    \"\"\"Parse and validate YAML into config.\"\"\"\n    try:\n        return cast(BaseConfig, ProtocolConfig.model_validate(data))\n    except ValidationError as e:\n        # Optionally transform error for better messages\n        raise\n</code></pre> <p>The returned config is passed to templates and post-generation hooks.</p>"},{"location":"extending/generators/#rendering","title":"Rendering","text":"<p>The <code>render</code> method passes data to Jinja2 templates:</p>"},{"location":"extending/generators/#passing-the-whole-config","title":"Passing the Whole Config","text":"<pre><code>def render(self, config: Any, template: Template) -&gt; str:\n    \"\"\"Pass entire config to template.\"\"\"\n    cfg: ProtocolConfig = config\n    return template.render(config=cfg)\n</code></pre> <p>Template usage: <pre><code>{% for msg in config.messages %}\n#define MSG_{{ msg.name | upper }} {{ msg.id }}\n{% endfor %}\n</code></pre></p>"},{"location":"extending/generators/#passing-individual-variables","title":"Passing Individual Variables","text":"<pre><code>def render(self, config: Any, template: Template) -&gt; str:\n    \"\"\"Pass individual variables to template.\"\"\"\n    cfg: ProtocolConfig = config\n    return template.render(\n        name=cfg.name,\n        version=cfg.version,\n        messages=sorted(cfg.messages, key=lambda m: m.id),\n        requests=cfg.requests,\n        responses=cfg.responses,\n    )\n</code></pre> <p>Template usage: <pre><code>// {{ name }} v{{ version }}\n{% for msg in messages %}\n...\n{% endfor %}\n</code></pre></p>"},{"location":"extending/generators/#adding-extra-context","title":"Adding Extra Context","text":"<pre><code>from datetime import datetime\n\ndef render(self, config: Any, template: Template) -&gt; str:\n    cfg: ProtocolConfig = config\n    return template.render(\n        config=cfg,\n        generated_on=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n        generator_version=\"1.0.0\",\n    )\n</code></pre>"},{"location":"extending/generators/#post-generation-hooks","title":"Post-Generation Hooks","text":"<p>The <code>post_generate</code> method runs after all templates are rendered. Use it to copy additional files:</p> <pre><code>def post_generate(\n    self, config: BaseConfig, output: Path, generated_extensions: set[str]\n) -&gt; list[str]:\n    \"\"\"Copy extra files after generation.\"\"\"\n    copied_files = []\n\n    # Only copy when C header is generated\n    if \"h\" in generated_extensions:\n        # Copy utility header\n        src = self.templates_path / \"protocol_utils.h\"\n        if src.exists():\n            dst = output / \"protocol_utils.h\"\n            dst.write_text(src.read_text())\n            copied_files.append(\"protocol_utils.h\")\n\n    # Only copy when Python is generated\n    if \"py\" in generated_extensions:\n        src = self.templates_path / \"protocol_base.py\"\n        if src.exists():\n            dst = output / f\"{config.output_filename}_base.py\"\n            dst.write_text(src.read_text())\n            copied_files.append(f\"{config.output_filename}_base.py\")\n\n    return copied_files\n</code></pre>"},{"location":"extending/generators/#static-files-for-post-generation","title":"Static Files for Post-Generation","text":"<p>Place static files in your <code>templates/</code> directory:</p> <pre><code>protocol/\n\u251c\u2500\u2500 generator.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 template.h.j2\n    \u251c\u2500\u2500 template.py.j2\n    \u251c\u2500\u2500 protocol_utils.h      # Static file, copied as-is\n    \u2514\u2500\u2500 protocol_base.py      # Static file, copied as-is\n</code></pre>"},{"location":"extending/generators/#complete-example","title":"Complete Example","text":"<pre><code># generator.py\n\"\"\"Protocol domain generator.\"\"\"\n\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, cast\n\nfrom jinja2 import Template\n\nfrom embgen.domains import DomainGenerator\nfrom embgen.models import BaseConfig\nfrom .models import ProtocolConfig\n\n\nclass ProtocolGenerator(DomainGenerator):\n    \"\"\"Generator for protocol message definitions.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"protocol\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Generate code from protocol message definitions\"\n\n    def detect(self, data: dict[str, Any]) -&gt; bool:\n        \"\"\"Detect protocol YAML by checking for messages key.\"\"\"\n        if data.get(\"domain\") == \"protocol\":\n            return True\n        if \"messages\" not in data:\n            return False\n        # Verify message structure\n        messages = data.get(\"messages\", [])\n        return bool(messages) and \"id\" in messages[0]\n\n    def validate(self, data: dict[str, Any]) -&gt; BaseConfig:\n        \"\"\"Validate YAML into ProtocolConfig.\"\"\"\n        return cast(BaseConfig, ProtocolConfig.model_validate(data))\n\n    def render(self, config: Any, template: Template) -&gt; str:\n        \"\"\"Render protocol config to template.\"\"\"\n        cfg = config if isinstance(config, ProtocolConfig) else ProtocolConfig.model_validate(config)\n\n        # Sort messages by ID for consistent output\n        messages = sorted(cfg.messages, key=lambda m: m.id)\n\n        return template.render(\n            name=cfg.name,\n            namespace=cfg.namespace or cfg.name.lower(),\n            version=cfg.version,\n            messages=messages,\n            requests=[m for m in messages if m.type.value == \"request\"],\n            responses=[m for m in messages if m.type.value == \"response\"],\n            generated_on=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n        )\n\n    @property\n    def templates_path(self) -&gt; Path:\n        return Path(__file__).parent / \"templates\"\n\n    def post_generate(\n        self, config: BaseConfig, output: Path, generated_extensions: set[str]\n    ) -&gt; list[str]:\n        \"\"\"Copy utility files.\"\"\"\n        copied = []\n\n        if \"h\" in generated_extensions:\n            for filename in [\"protocol_utils.h\", \"protocol_types.h\"]:\n                src = self.templates_path / filename\n                if src.exists():\n                    (output / filename).write_text(src.read_text())\n                    copied.append(filename)\n\n        if \"py\" in generated_extensions:\n            src = self.templates_path / \"protocol_base.py\"\n            if src.exists():\n                dst_name = f\"{config.output_filename}_base.py\"\n                (output / dst_name).write_text(src.read_text())\n                copied.append(dst_name)\n\n        return copied\n</code></pre>"},{"location":"extending/models/","title":"Writing Models","text":"<p>Models define the structure of your YAML configuration and provide validation. embgen uses Pydantic for data validation.</p>"},{"location":"extending/models/#base-configuration","title":"Base Configuration","text":"<p>All domain configurations must ultimately provide:</p> <ul> <li><code>name</code> \u2014 The human-readable name</li> <li><code>output_filename</code> \u2014 The base filename for generated files</li> </ul> <p>You can either extend <code>BaseConfig</code> or implement these yourself:</p> <pre><code>from embgen.models import BaseConfig\n\nclass MyConfig(BaseConfig):\n    \"\"\"Configuration for my domain.\n\n    Inherits:\n        name: str\n        file: str | None (optional output filename override)\n        output_filename: property (returns file or lowercase name)\n    \"\"\"\n    # Add your domain-specific fields\n    items: list[str] = []\n</code></pre>"},{"location":"extending/models/#defining-models","title":"Defining Models","text":""},{"location":"extending/models/#basic-model","title":"Basic Model","text":"<pre><code># models.py\nfrom typing import Optional\nfrom pydantic import BaseModel\nfrom embgen.models import BaseConfig\n\nclass MyConfig(BaseConfig):\n    \"\"\"Top-level configuration.\"\"\"\n\n    description: Optional[str] = None\n    version: str = \"1.0\"\n    items: list[\"Item\"] = []\n\nclass Item(BaseModel):\n    \"\"\"An item in the configuration.\"\"\"\n\n    name: str\n    value: int\n    enabled: bool = True\n</code></pre> <p>This validates YAML like:</p> <pre><code>name: MyProject\ndescription: Example project\nversion: \"2.0\"\nitems:\n  - name: foo\n    value: 42\n  - name: bar\n    value: 100\n    enabled: false\n</code></pre>"},{"location":"extending/models/#using-enums","title":"Using Enums","text":"<pre><code>from enum import StrEnum\nfrom pydantic import BaseModel\n\nclass ItemType(StrEnum):\n    SIMPLE = \"simple\"\n    COMPLEX = \"complex\"\n\nclass Item(BaseModel):\n    name: str\n    type: ItemType = ItemType.SIMPLE\n</code></pre> <p>YAML usage:</p> <pre><code>items:\n  - name: foo\n    type: simple\n  - name: bar\n    type: complex\n</code></pre>"},{"location":"extending/models/#nested-enumerations","title":"Nested Enumerations","text":"<p>For enums that are defined in YAML (not code), use the shared <code>Enum</code> model:</p> <pre><code>from embgen.models import Enum\n\nclass Item(BaseModel):\n    name: str\n    values: list[Enum] | None = None\n</code></pre> <p>YAML usage:</p> <pre><code>items:\n  - name: status\n    values:\n      - { name: OK, value: 0, description: \"Success\" }\n      - { name: ERROR, value: 1, description: \"Failure\" }\n</code></pre>"},{"location":"extending/models/#validation","title":"Validation","text":""},{"location":"extending/models/#field-validators","title":"Field Validators","text":"<p>Use Pydantic validators for custom validation logic:</p> <pre><code>from pydantic import BaseModel, field_validator\n\nclass Item(BaseModel):\n    name: str\n    value: int\n\n    @field_validator(\"value\")\n    @classmethod\n    def value_must_be_positive(cls, v: int) -&gt; int:\n        if v &lt; 0:\n            raise ValueError(\"value must be positive\")\n        return v\n</code></pre>"},{"location":"extending/models/#cross-field-validation","title":"Cross-Field Validation","text":"<pre><code>from pydantic import BaseModel, model_validator\n\nclass Config(BaseModel):\n    min_value: int\n    max_value: int\n\n    @model_validator(mode=\"after\")\n    def check_range(self) -&gt; \"Config\":\n        if self.min_value &gt;= self.max_value:\n            raise ValueError(\"min_value must be less than max_value\")\n        return self\n</code></pre>"},{"location":"extending/models/#default-value-transformation","title":"Default Value Transformation","text":"<pre><code>from typing import Any\nfrom pydantic import BaseModel, field_validator, ValidationInfo\n\nclass Argument(BaseModel):\n    name: str\n    default: int | str | None = None\n    enums: list[Enum] | None = None\n\n    @field_validator(\"default\", mode=\"before\")\n    @classmethod\n    def resolve_enum_default(cls, v: Any, info: ValidationInfo) -&gt; Any:\n        \"\"\"Convert string default to Enum if enums are defined.\"\"\"\n        enums = info.data.get(\"enums\")\n        if enums and isinstance(v, str):\n            for enum in enums:\n                if enum.name == v:\n                    return enum\n        return v\n</code></pre>"},{"location":"extending/models/#computed-fields","title":"Computed Fields","text":"<p>Add properties that are computed from other fields:</p> <pre><code>from pydantic import BaseModel, computed_field\n\nclass Argument(BaseModel):\n    name: str\n    type: str  # e.g., \"B\", \"H\", \"I\"\n\n    @computed_field\n    def type_size(self) -&gt; int:\n        \"\"\"Get size in bytes for the type.\"\"\"\n        sizes = {\"B\": 1, \"H\": 2, \"I\": 4, \"Q\": 8}\n        return sizes.get(self.type, 0)\n\n    @computed_field\n    def type_python(self) -&gt; str:\n        \"\"\"Get Python type name.\"\"\"\n        types = {\"B\": \"int\", \"H\": \"int\", \"f\": \"float\", \"?\": \"bool\"}\n        return types.get(self.type, \"Any\")\n</code></pre> <p>These computed fields are available in templates:</p> <pre><code>{{ arg.name }}: {{ arg.type_python }}  # foo: int\n</code></pre>"},{"location":"extending/models/#complete-example","title":"Complete Example","text":"<p>Here's a complete model for a protocol domain:</p> <pre><code># models.py\n\"\"\"Data models for the protocol domain.\"\"\"\n\nfrom enum import StrEnum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field, computed_field\n\nfrom embgen.models import BaseConfig, Enum\n\n\nclass MessageType(StrEnum):\n    \"\"\"Message type enumeration.\"\"\"\n    REQUEST = \"request\"\n    RESPONSE = \"response\"\n    NOTIFICATION = \"notification\"\n\n\nclass Field(BaseModel):\n    \"\"\"A field within a message.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    type: str  # e.g., \"uint8\", \"uint16\", \"string\"\n    optional: bool = False\n    enums: Optional[list[Enum]] = None\n\n    @computed_field\n    def c_type(self) -&gt; str:\n        \"\"\"Get C type for this field.\"\"\"\n        type_map = {\n            \"uint8\": \"uint8_t\",\n            \"uint16\": \"uint16_t\", \n            \"uint32\": \"uint32_t\",\n            \"int8\": \"int8_t\",\n            \"int16\": \"int16_t\",\n            \"int32\": \"int32_t\",\n            \"string\": \"char*\",\n            \"bool\": \"bool\",\n        }\n        return type_map.get(self.type, \"void*\")\n\n\nclass Message(BaseModel):\n    \"\"\"A protocol message.\"\"\"\n\n    name: str\n    id: int\n    type: MessageType = MessageType.REQUEST\n    description: Optional[str] = None\n    fields: list[Field] = Field(default_factory=list)\n\n\nclass ProtocolConfig(BaseConfig):\n    \"\"\"Top-level protocol configuration.\"\"\"\n\n    version: str = \"1.0\"\n    namespace: Optional[str] = None\n    messages: list[Message]\n\n    @property\n    def requests(self) -&gt; list[Message]:\n        \"\"\"Get all request messages.\"\"\"\n        return [m for m in self.messages if m.type == MessageType.REQUEST]\n\n    @property\n    def responses(self) -&gt; list[Message]:\n        \"\"\"Get all response messages.\"\"\"\n        return [m for m in self.messages if m.type == MessageType.RESPONSE]\n</code></pre> <p>Example YAML:</p> <pre><code>name: MyProtocol\nversion: \"2.0\"\nnamespace: myproto\n\nmessages:\n  - name: Connect\n    id: 1\n    type: request\n    description: \"Connect to the device\"\n    fields:\n      - name: device_id\n        type: uint32\n        description: \"Device identifier\"\n      - name: timeout_ms\n        type: uint16\n        optional: true\n\n  - name: ConnectResponse\n    id: 2\n    type: response\n    fields:\n      - name: status\n        type: uint8\n        enums:\n          - { name: OK, value: 0 }\n          - { name: ERROR, value: 1 }\n          - { name: TIMEOUT, value: 2 }\n</code></pre>"},{"location":"extending/multifile/","title":"Multifile Templates","text":"<p>Sometimes you need to generate multiple related files from a single template group. embgen supports multifile templates for these cases.</p>"},{"location":"extending/multifile/#use-cases","title":"Use Cases","text":"<ul> <li>Header and Source \u2014 Generate both <code>.h</code> and <code>.c</code> files together</li> <li>Multiple Modules \u2014 Generate several related SystemVerilog files</li> <li>Split Output \u2014 Separate definitions from implementations</li> </ul>"},{"location":"extending/multifile/#naming-convention","title":"Naming Convention","text":"<p>Multifile templates use the <code>_multi</code> suffix:</p> <pre><code>template.&lt;group&gt;_multi.&lt;extension&gt;[.&lt;suffix&gt;].j2\n</code></pre>"},{"location":"extending/multifile/#different-extensions-same-group","title":"Different Extensions (Same Group)","text":"<p>Generate files with different extensions:</p> <pre><code>template.c_multi.h.j2    \u2192 &lt;name&gt;.h\ntemplate.c_multi.c.j2    \u2192 &lt;name&gt;.c\n</code></pre> <p>CLI usage: <code>--c-multi</code> generates both files</p>"},{"location":"extending/multifile/#same-extension-with-suffix","title":"Same Extension (With Suffix)","text":"<p>Generate multiple files with the same extension:</p> <pre><code>template.sv_multi.sv.1.j2    \u2192 &lt;name&gt;_1.sv\ntemplate.sv_multi.sv.2.j2    \u2192 &lt;name&gt;_2.sv\n</code></pre> <p>CLI usage: <code>--sv-multi</code> generates both files</p>"},{"location":"extending/multifile/#examples","title":"Examples","text":""},{"location":"extending/multifile/#c-header-and-source","title":"C Header and Source","text":"<p>Create two templates for header and implementation:</p> <pre><code>templates/\n\u251c\u2500\u2500 template.c_multi.h.j2    # Header file\n\u2514\u2500\u2500 template.c_multi.c.j2    # Source file\n</code></pre> <p>template.c_multi.h.j2: <pre><code>// {{ name }}.h - Generated by embgen\n#ifndef {{ name | upper }}_H\n#define {{ name | upper }}_H\n\n{% for item in config.items %}\nvoid {{ item.name }}(void);\n{% endfor %}\n\n#endif\n</code></pre></p> <p>template.c_multi.c.j2: <pre><code>// {{ name }}.c - Generated by embgen\n#include \"{{ name }}.h\"\n\n{% for item in config.items %}\nvoid {{ item.name }}(void) {\n    // Implementation for {{ item.name }}\n}\n\n{% endfor %}\n</code></pre></p> <p>CLI usage: <pre><code>embgen mydomain config.yml -o output/ --c-multi\n</code></pre></p> <p>Output: <pre><code>output/\n\u251c\u2500\u2500 myconfig.h\n\u2514\u2500\u2500 myconfig.c\n</code></pre></p>"},{"location":"extending/multifile/#systemverilog-modules","title":"SystemVerilog Modules","text":"<p>Generate multiple related Verilog files:</p> <pre><code>templates/\n\u251c\u2500\u2500 template.sv_multi.sv.1.j2    # Top module\n\u251c\u2500\u2500 template.sv_multi.sv.2.j2    # Controller\n\u2514\u2500\u2500 template.sv_multi.sv.3.j2    # Datapath\n</code></pre> <p>template.sv_multi.sv.1.j2: <pre><code>// {{ name }}_top.sv\nmodule {{ name }}_top (\n    input clk,\n    input rst_n\n);\n    {{ name }}_ctrl ctrl_inst (...);\n    {{ name }}_dp dp_inst (...);\nendmodule\n</code></pre></p> <p>template.sv_multi.sv.2.j2: <pre><code>// {{ name }}_ctrl.sv\nmodule {{ name }}_ctrl (...);\n    // Controller logic\nendmodule\n</code></pre></p> <p>template.sv_multi.sv.3.j2: <pre><code>// {{ name }}_dp.sv\nmodule {{ name }}_dp (...);\n    // Datapath logic\nendmodule\n</code></pre></p> <p>CLI usage: <pre><code>embgen mydomain config.yml -o output/ --sv-multi\n</code></pre></p> <p>Output: <pre><code>output/\n\u251c\u2500\u2500 myconfig_1.sv\n\u251c\u2500\u2500 myconfig_2.sv\n\u2514\u2500\u2500 myconfig_3.sv\n</code></pre></p>"},{"location":"extending/multifile/#mixing-single-and-multifile","title":"Mixing Single and Multifile","text":"<p>You can have both single-file and multifile templates in the same domain:</p> <pre><code>templates/\n\u251c\u2500\u2500 template.h.j2            # Single: --h\n\u251c\u2500\u2500 template.md.j2           # Single: --md\n\u251c\u2500\u2500 template.c_multi.h.j2    # Multifile: --c-multi\n\u2514\u2500\u2500 template.c_multi.c.j2    # Multifile: --c-multi\n</code></pre> <p>CLI usage: <pre><code># Generate just the header\nembgen mydomain config.yml -o output/ --h\n\n# Generate header + source pair\nembgen mydomain config.yml -o output/ --c-multi\n\n# Generate everything\nembgen mydomain config.yml -o output/ --h --md --c-multi\n</code></pre></p>"},{"location":"extending/multifile/#output-filename-patterns","title":"Output Filename Patterns","text":"Template Config Name Output File <code>template.h.j2</code> <code>MyConfig</code> <code>myconfig.h</code> <code>template.c_multi.h.j2</code> <code>MyConfig</code> <code>myconfig.h</code> <code>template.c_multi.c.j2</code> <code>MyConfig</code> <code>myconfig.c</code> <code>template.sv_multi.sv.1.j2</code> <code>MyConfig</code> <code>myconfig_1.sv</code> <code>template.sv_multi.sv.2.j2</code> <code>MyConfig</code> <code>myconfig_2.sv</code> <p>The base filename comes from <code>config.output_filename</code> (which defaults to the lowercase <code>name</code> or can be overridden with the <code>file</code> field).</p>"},{"location":"extending/multifile/#python-api","title":"Python API","text":"<p>When using the Python API, multifile groups are discovered separately:</p> <pre><code>from embgen.templates import discover_templates\n\nsingle_templates, multifile_groups = discover_templates(templates_path)\n\n# single_templates: {\"h\": (\"C Header\", \"template.h.j2\"), ...}\n# multifile_groups: {\"c\": MultifileGroup(...), \"sv\": MultifileGroup(...)}\n\n# Access multifile group info\nc_group = multifile_groups[\"c\"]\nprint(c_group.description)     # \"C Source\"\nprint(c_group.templates)       # [TemplateInfo(...), TemplateInfo(...)]\n</code></pre> <p>Generating multifile output:</p> <pre><code>from embgen.generator import CodeGenerator\n\ncode_gen = CodeGenerator(generator, output_path)\n\n# Generate a multifile group\nfor template_info in multifile_groups[\"c\"].templates:\n    code_gen.render_to_file(\n        config,\n        template_info.filename,\n        template_info.output_ext,\n        template_info.suffix,\n    )\n</code></pre>"},{"location":"extending/multifile/#template-discovery-rules","title":"Template Discovery Rules","text":"<ol> <li>Templates must end in <code>.j2</code> or <code>.jinja</code></li> <li>Files starting with <code>_</code> are ignored (use for includes)</li> <li>Single templates: <code>template.&lt;ext&gt;.j2</code></li> <li>Multifile templates: <code>template.&lt;group&gt;_multi.&lt;ext&gt;[.&lt;suffix&gt;].j2</code></li> </ol> <p>The group name becomes the CLI flag: <code>--&lt;group&gt;-multi</code></p>"},{"location":"extending/templates/","title":"Writing Templates","text":"<p>Templates are Jinja2 files that define the output format for your generated code. embgen automatically discovers templates based on their naming convention.</p>"},{"location":"extending/templates/#template-naming-convention","title":"Template Naming Convention","text":"<p>Templates must follow this naming pattern:</p> <pre><code>template.&lt;extension&gt;.j2\n</code></pre> <p>Examples:</p> Template File Output Extension CLI Flag <code>template.h.j2</code> <code>.h</code> <code>--h</code> <code>template.py.j2</code> <code>.py</code> <code>--py</code> <code>template.md.j2</code> <code>.md</code> <code>--md</code> <code>template.c.j2</code> <code>.c</code> <code>--c</code> <code>template.rs.j2</code> <code>.rs</code> <code>--rs</code>"},{"location":"extending/templates/#template-location","title":"Template Location","text":"<p>Templates must be in a <code>templates/</code> subdirectory of your domain:</p> <pre><code>mydomain/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 generator.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 template.h.j2\n    \u251c\u2500\u2500 template.py.j2\n    \u2514\u2500\u2500 template.md.j2\n</code></pre>"},{"location":"extending/templates/#available-context","title":"Available Context","text":"<p>Your generator's <code>render()</code> method determines what variables are available in templates:</p> <pre><code>def render(self, config: Any, template: Template) -&gt; str:\n    return template.render(\n        config=cfg,           # The full config object\n        name=cfg.name,        # Individual fields\n        items=cfg.items,\n        generated_on=\"...\",   # Extra context\n    )\n</code></pre>"},{"location":"extending/templates/#common-variables","title":"Common Variables","text":"<p>Most generators provide:</p> Variable Type Description <code>config</code> Your config class Full configuration object <code>name</code> <code>str</code> Configuration name <code>generated_on</code> <code>str</code> Timestamp"},{"location":"extending/templates/#jinja2-basics","title":"Jinja2 Basics","text":""},{"location":"extending/templates/#variables","title":"Variables","text":"<pre><code>{{ config.name }}\n{{ item.description }}\n</code></pre>"},{"location":"extending/templates/#loops","title":"Loops","text":"<pre><code>{% for item in config.items %}\n{{ item.name }} = {{ item.value }}\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#conditionals","title":"Conditionals","text":"<pre><code>{% if item.description %}\n// {{ item.description }}\n{% endif %}\n\n{% if item.optional %}\n{{ item.name }}?\n{% else %}\n{{ item.name }}\n{% endif %}\n</code></pre>"},{"location":"extending/templates/#filters","title":"Filters","text":"<pre><code>{{ name | upper }}          {# MYNAME #}\n{{ name | lower }}          {# myname #}\n{{ name | title }}          {# Myname #}\n{{ items | length }}        {# 5 #}\n{{ items | first }}         {# First item #}\n{{ items | last }}          {# Last item #}\n{{ value | default(0) }}    {# Use 0 if value is undefined #}\n</code></pre>"},{"location":"extending/templates/#template-examples","title":"Template Examples","text":""},{"location":"extending/templates/#c-header-template","title":"C Header Template","text":"<pre><code>// {{ name }} - Generated by embgen\n// DO NOT EDIT - Generated on {{ generated_on }}\n\n#ifndef {{ name | upper }}_H\n#define {{ name | upper }}_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n{% for item in config.items %}\n{% if item.description %}\n/** {{ item.description }} */\n{% endif %}\n#define {{ name | upper }}_{{ item.name | upper }} {{ item.value }}\n{% endfor %}\n\n{% for item in config.items %}\n{% if item.enums %}\ntypedef enum {\n{% for e in item.enums %}\n    {{ item.name | upper }}_{{ e.name | upper }} = {{ e.value }},{% if e.description %} /**&lt; {{ e.description }} */{% endif %}\n\n{% endfor %}\n} {{ item.name | title }}Enum;\n\n{% endif %}\n{% endfor %}\n\n#endif // {{ name | upper }}_H\n</code></pre>"},{"location":"extending/templates/#python-template","title":"Python Template","text":"<pre><code>\"\"\"{{ name }} - Generated by embgen.\n\nDO NOT EDIT - Generated on {{ generated_on }}.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom enum import IntEnum\n{% if config.items | selectattr(\"enums\") | list %}\n\n{% for item in config.items %}\n{% if item.enums %}\nclass {{ item.name | title }}(IntEnum):\n    \"\"\"{{ item.description or item.name }}\"\"\"\n{% for e in item.enums %}\n    {{ e.name }} = {{ e.value }}{% if e.description %}  # {{ e.description }}{% endif %}\n\n{% endfor %}\n\n{% endif %}\n{% endfor %}\n{% endif %}\n\n{% for item in config.items %}\n@dataclass\nclass {{ item.name | title }}:\n    \"\"\"{{ item.description or item.name }}\"\"\"\n\n    value: int = {{ item.value }}\n{% if item.enums %}\n    enum: {{ item.name | title }} = {{ item.name | title }}.{{ item.enums[0].name }}\n{% endif %}\n\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#markdown-template","title":"Markdown Template","text":"<pre><code># {{ name }}\n\n&gt; Generated by embgen on {{ generated_on }}\n\n## Overview\n\n{{ config.description or \"No description provided.\" }}\n\n## Items\n\n| Name | Value | Description |\n| ---- | ----- | ----------- |\n{% for item in config.items %}\n| `{{ item.name }}` | {{ item.value }} | {{ item.description or \"-\" }} |\n{% endfor %}\n\n{% for item in config.items %}\n{% if item.enums %}\n### {{ item.name }} Values\n\n| Name | Value | Description |\n| ---- | ----- | ----------- |\n{% for e in item.enums %}\n| `{{ e.name }}` | {{ e.value }} | {{ e.description or \"-\" }} |\n{% endfor %}\n\n{% endif %}\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#advanced-jinja2-features","title":"Advanced Jinja2 Features","text":""},{"location":"extending/templates/#whitespace-control","title":"Whitespace Control","text":"<p>Use <code>-</code> to strip whitespace:</p> <pre><code>{%- for item in items -%}\n{{ item.name }}\n{%- endfor -%}\n</code></pre> <p>embgen configures Jinja2 with <code>trim_blocks=True</code> and <code>lstrip_blocks=True</code> by default.</p>"},{"location":"extending/templates/#macros","title":"Macros","text":"<p>Define reusable template functions:</p> <pre><code>{% macro type_to_c(type_name) -%}\n{% if type_name == \"uint8\" %}uint8_t\n{% elif type_name == \"uint16\" %}uint16_t\n{% elif type_name == \"uint32\" %}uint32_t\n{% elif type_name == \"string\" %}char*\n{% else %}void*\n{% endif %}\n{%- endmacro %}\n\ntypedef struct {\n{% for field in item.fields %}\n    {{ type_to_c(field.type) }} {{ field.name }};\n{% endfor %}\n} {{ item.name }};\n</code></pre>"},{"location":"extending/templates/#includes","title":"Includes","text":"<p>Split templates into reusable parts:</p> <pre><code>templates/\n\u251c\u2500\u2500 template.h.j2\n\u251c\u2500\u2500 _macros.h.j2      # Shared macros (not discovered as output)\n\u2514\u2500\u2500 _types.h.j2       # Shared type definitions\n</code></pre> <pre><code>{% include \"_macros.h.j2\" %}\n{% include \"_types.h.j2\" %}\n\n// Main template content...\n</code></pre> <p>Note</p> <p>Files starting with <code>_</code> are not discovered as output templates.</p>"},{"location":"extending/templates/#set-variables","title":"Set Variables","text":"<pre><code>{% set sorted_items = config.items | sort(attribute=\"value\") %}\n{% for item in sorted_items %}\n...\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#loop-variables","title":"Loop Variables","text":"<pre><code>{% for item in items %}\n{{ loop.index }}      {# 1-indexed counter #}\n{{ loop.index0 }}     {# 0-indexed counter #}\n{{ loop.first }}      {# True if first iteration #}\n{{ loop.last }}       {# True if last iteration #}\n{{ loop.length }}     {# Total number of items #}\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#custom-filters","title":"Custom Filters","text":"<p>You can add custom filters in your generator:</p> <pre><code>def render(self, config: Any, template: Template) -&gt; str:\n    # Add custom filter to environment\n    template.environment.filters[\"to_snake_case\"] = self._to_snake_case\n    return template.render(config=cfg)\n\n@staticmethod\ndef _to_snake_case(s: str) -&gt; str:\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    import re\n    return re.sub(r'(?&lt;!^)(?=[A-Z])', '_', s).lower()\n</code></pre> <p>Usage in template: <pre><code>{{ \"MyClassName\" | to_snake_case }}  {# my_class_name #}\n</code></pre></p>"},{"location":"extending/templates/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"extending/templates/#1-use-descriptive-comments","title":"1. Use Descriptive Comments","text":"<pre><code>{# Generate enum definitions #}\n{% for item in items %}\n...\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#2-handle-optional-fields","title":"2. Handle Optional Fields","text":"<pre><code>{% if item.description %}\n/** {{ item.description }} */\n{% endif %}\n</code></pre>"},{"location":"extending/templates/#3-use-default-values","title":"3. Use Default Values","text":"<pre><code>{{ item.description | default(\"No description\") }}\n</code></pre>"},{"location":"extending/templates/#4-sort-for-consistent-output","title":"4. Sort for Consistent Output","text":"<pre><code>{% for item in config.items | sort(attribute=\"name\") %}\n...\n{% endfor %}\n</code></pre>"},{"location":"extending/templates/#5-format-long-lines","title":"5. Format Long Lines","text":"<pre><code>{# Use multiple lines for complex expressions #}\n{% set filtered_items = config.items \n    | selectattr(\"enabled\", \"true\") \n    | sort(attribute=\"name\") \n    | list %}\n</code></pre>"},{"location":"usage/cli/","title":"CLI Usage","text":"<p>embgen provides a command-line interface for generating code from YAML configuration files.</p>"},{"location":"usage/cli/#basic-syntax","title":"Basic Syntax","text":"<pre><code>embgen [OPTIONS] COMMAND INPUT -o OUTPUT [FORMAT_FLAGS]\n</code></pre>"},{"location":"usage/cli/#global-options","title":"Global Options","text":"Option Description <code>--help</code>, <code>-h</code> Show help message <code>-d</code>, <code>--debug</code> Enable debug output with timing information <code>--domains-dir PATH</code> Load additional domains from this directory"},{"location":"usage/cli/#commands","title":"Commands","text":""},{"location":"usage/cli/#domain-subcommands","title":"Domain Subcommands","text":"<p>Each domain is exposed as a subcommand. The built-in domains are:</p> <pre><code>embgen commands INPUT -o OUTPUT [FLAGS]   # Generate from command definitions\nembgen registers INPUT -o OUTPUT [FLAGS]  # Generate from register maps\n</code></pre>"},{"location":"usage/cli/#auto-detect-domain","title":"Auto-detect Domain","text":"<p>Use <code>auto</code> to let embgen detect the domain from the YAML content:</p> <pre><code>embgen auto INPUT -o OUTPUT [FLAGS]\n</code></pre>"},{"location":"usage/cli/#create-new-domain","title":"Create New Domain","text":"<p>Use <code>new</code> to scaffold a new domain:</p> <pre><code>embgen new DOMAIN_NAME [OPTIONS]\n</code></pre> Option Description <code>--location PATH</code> Directory where the domain folder will be created <code>--builtin</code> Create the domain in embgen's built-in domains directory"},{"location":"usage/cli/#domain-specific-options","title":"Domain-Specific Options","text":""},{"location":"usage/cli/#common-options","title":"Common Options","text":"<p>All domain subcommands share these options:</p> Option Description <code>INPUT</code> Path to the YAML configuration file <code>-o</code>, <code>--output PATH</code> Output directory for generated files"},{"location":"usage/cli/#output-format-flags","title":"Output Format Flags","text":"<p>Each domain defines its own output format flags based on available templates:</p> CommandsRegisters Flag Output <code>--h</code> C header file (<code>commands.h</code>) <code>--py</code> Python module (<code>commands.py</code> + <code>commands_base.py</code>) <code>--md</code> Markdown documentation (<code>commands.md</code>) Flag Output <code>--h</code> C header file (<code>&lt;name&gt;.h</code> + <code>reg_common.h/.c</code>) <code>--py</code> Python module (<code>&lt;name&gt;.py</code>) <code>--md</code> Markdown documentation (<code>&lt;name&gt;.md</code>)"},{"location":"usage/cli/#examples","title":"Examples","text":""},{"location":"usage/cli/#generate-c-header-only","title":"Generate C Header Only","text":"<pre><code>embgen commands mycommands.yml -o generated/ --h\n</code></pre>"},{"location":"usage/cli/#generate-multiple-formats","title":"Generate Multiple Formats","text":"<pre><code>embgen commands mycommands.yml -o generated/ --h --py --md\n</code></pre>"},{"location":"usage/cli/#generate-with-debug-output","title":"Generate with Debug Output","text":"<pre><code>embgen -d commands mycommands.yml -o generated/ --h\n</code></pre> <p>This shows timing information:</p> <pre><code>[12:34:56] INFO     Loading YAML file from mycommands.yml\n[12:34:56] INFO     Generating C Header... done after 0.02s\n[12:34:56] INFO     Generation complete in 0.05s\n</code></pre>"},{"location":"usage/cli/#auto-detect-domain-type","title":"Auto-detect Domain Type","text":"<pre><code>embgen auto config.yml -o generated/ --h\n</code></pre> <p>embgen examines the YAML structure to determine the appropriate domain:</p> <ul> <li>Files with a <code>commands</code> key \u2192 Commands domain</li> <li>Files with a <code>regmap</code> key \u2192 Registers domain</li> </ul>"},{"location":"usage/cli/#use-custom-domains","title":"Use Custom Domains","text":"<pre><code># Load domains from a custom directory\nembgen --domains-dir ./my_domains mydom config.yml -o output/ --h\n</code></pre>"},{"location":"usage/cli/#create-a-new-domain","title":"Create a New Domain","text":"<pre><code># Create in a custom location\nembgen new mydomain --location ./domains\n\n# Create as a built-in domain\nembgen new mydomain --builtin\n</code></pre>"},{"location":"usage/cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>EMBGEN_DOMAINS_DIR</code> Additional directory to search for domains <p>This allows you to set up custom domains without specifying <code>--domains-dir</code> every time:</p> <pre><code>export EMBGEN_DOMAINS_DIR=/path/to/my/domains\nembgen mydom config.yml -o output/ --h\n</code></pre>"},{"location":"usage/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Error (invalid arguments, file not found, validation error, etc.)"},{"location":"usage/cli/#error-handling","title":"Error Handling","text":""},{"location":"usage/cli/#file-not-found","title":"File Not Found","text":"<pre><code>$ embgen commands nonexistent.yml -o output/ --h\nERROR    Generation failed: Input file .../nonexistent.yml does not exist\n</code></pre>"},{"location":"usage/cli/#no-output-format-specified","title":"No Output Format Specified","text":"<pre><code>$ embgen commands config.yml -o output/\nERROR    No output formats specified. Use -h to see available formats.\n</code></pre>"},{"location":"usage/cli/#invalid-yaml","title":"Invalid YAML","text":"<pre><code>$ embgen commands invalid.yml -o output/ --h\nError: Failed to load YAML file\n</code></pre>"},{"location":"usage/cli/#auto-detect-failure","title":"Auto-detect Failure","text":"<pre><code>$ embgen auto unknown.yml -o output/ --h\nError: Could not auto-detect domain. Abailable: [...]\n</code></pre>"},{"location":"usage/python-api/","title":"Python API","text":"<p>embgen can be used as a Python library for programmatic code generation.</p>"},{"location":"usage/python-api/#quick-start","title":"Quick Start","text":"<pre><code>from pathlib import Path\nfrom embgen.discovery import discover_domains\nfrom embgen.generator import CodeGenerator\n\n# Discover available domains\ndomains = discover_domains()\n\n# Get the commands generator\ncommands_gen = domains[\"commands\"]\n\n# Create a code generator\ncode_gen = CodeGenerator(commands_gen, Path(\"output\"))\n\n# Generate from a YAML file\ntemplates = {\"h\": \"template.h.j2\", \"py\": \"template.py.j2\"}\ngenerated_files = code_gen.generate_from_file(Path(\"config.yml\"), templates)\n\nprint(f\"Generated: {generated_files}\")\n</code></pre>"},{"location":"usage/python-api/#core-classes","title":"Core Classes","text":""},{"location":"usage/python-api/#codegenerator","title":"CodeGenerator","text":"<p>The main orchestration class for code generation.</p> <pre><code>from embgen.generator import CodeGenerator\n\ncode_gen = CodeGenerator(domain_generator, output_path)\n</code></pre>"},{"location":"usage/python-api/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description <code>generator</code> <code>DomainGenerator</code> The domain generator to use <code>output_path</code> <code>Path</code> Directory for output files"},{"location":"usage/python-api/#methods","title":"Methods","text":""},{"location":"usage/python-api/#parse_yamlinput_path-path---dict","title":"<code>parse_yaml(input_path: Path) -&gt; dict</code>","text":"<p>Parse a YAML file and return the data as a dictionary.</p> <pre><code>data = code_gen.parse_yaml(Path(\"config.yml\"))\n</code></pre>"},{"location":"usage/python-api/#validatedata-dict---baseconfig","title":"<code>validate(data: dict) -&gt; BaseConfig</code>","text":"<p>Validate YAML data against the domain schema.</p> <pre><code>config = code_gen.validate(data)\n</code></pre>"},{"location":"usage/python-api/#generate_from_fileinput_path-path-templates-dict---liststr","title":"<code>generate_from_file(input_path: Path, templates: dict) -&gt; list[str]</code>","text":"<p>Generate output files from a YAML input file.</p> <pre><code>templates = {\"h\": \"template.h.j2\", \"md\": \"template.md.j2\"}\nfilenames = code_gen.generate_from_file(Path(\"config.yml\"), templates)\n</code></pre>"},{"location":"usage/python-api/#generateconfig-baseconfig-templates-dict---liststr","title":"<code>generate(config: BaseConfig, templates: dict) -&gt; list[str]</code>","text":"<p>Generate output files from an already-validated configuration.</p> <pre><code>config = code_gen.validate(data)\nfilenames = code_gen.generate(config, templates)\n</code></pre>"},{"location":"usage/python-api/#discovery-functions","title":"Discovery Functions","text":""},{"location":"usage/python-api/#discover_domains","title":"discover_domains","text":"<p>Discover all available domain generators.</p> <pre><code>from embgen.discovery import discover_domains\n\n# Discover built-in domains only\ndomains = discover_domains()\n# Returns: {\"commands\": CommandsGenerator, \"registers\": RegistersGenerator}\n\n# Include custom domains directory\ndomains = discover_domains(extra_domains_dir=Path(\"/path/to/domains\"))\n</code></pre>"},{"location":"usage/python-api/#detect_domain","title":"detect_domain","text":"<p>Auto-detect which domain should handle given YAML data.</p> <pre><code>from embgen.discovery import detect_domain, discover_domains\n\ndomains = discover_domains()\ndata = {\"name\": \"MyCommands\", \"commands\": [...]}\n\ndomain_name = detect_domain(data, domains)\n# Returns: \"commands\"\n</code></pre>"},{"location":"usage/python-api/#template-discovery","title":"Template Discovery","text":""},{"location":"usage/python-api/#discover_templates","title":"discover_templates","text":"<p>Discover available templates for a domain.</p> <pre><code>from embgen.templates import discover_templates\n\nsingle_templates, multifile_groups = discover_templates(templates_path)\n\n# single_templates: {\"h\": (\"C Header\", \"template.h.j2\"), ...}\n# multifile_groups: {\"c\": MultifileGroup(...), ...}\n</code></pre>"},{"location":"usage/python-api/#working-with-configurations","title":"Working with Configurations","text":""},{"location":"usage/python-api/#loading-and-validating","title":"Loading and Validating","text":"<pre><code>from pathlib import Path\nfrom embgen.discovery import discover_domains\nfrom embgen.generator import CodeGenerator\n\ndomains = discover_domains()\ncode_gen = CodeGenerator(domains[\"commands\"], Path(\"output\"))\n\n# Parse YAML\ndata = code_gen.parse_yaml(Path(\"commands.yml\"))\n\n# Validate and get typed config\nconfig = code_gen.validate(data)\n\n# Access config properties\nprint(f\"Name: {config.name}\")\nprint(f\"Output filename: {config.output_filename}\")\n</code></pre>"},{"location":"usage/python-api/#direct-model-instantiation","title":"Direct Model Instantiation","text":"<p>You can also create configurations directly in Python:</p> <pre><code>from embgen.domains.commands.models import CommandsConfig, Command, Argument\n\nconfig = CommandsConfig(\n    name=\"MyCommands\",\n    commands=[\n        Command(\n            name=\"ping\",\n            id=0,\n            description=\"Ping the device\",\n            args=[\n                Argument(name=\"probe_id\", type=\"B\", description=\"Probe ID\")\n            ]\n        )\n    ]\n)\n</code></pre>"},{"location":"usage/python-api/#custom-generation-pipeline","title":"Custom Generation Pipeline","text":""},{"location":"usage/python-api/#step-by-step-generation","title":"Step-by-Step Generation","text":"<pre><code>from pathlib import Path\nfrom embgen.discovery import discover_domains\nfrom embgen.generator import CodeGenerator\nfrom embgen.templates import discover_templates\n\n# 1. Set up\ndomains = discover_domains()\ngenerator = domains[\"commands\"]\ncode_gen = CodeGenerator(generator, Path(\"output\"))\n\n# 2. Discover available templates\nsingle, multifile = discover_templates(generator.templates_path)\nprint(f\"Available formats: {list(single.keys())}\")\n\n# 3. Load and validate\ndata = code_gen.parse_yaml(Path(\"config.yml\"))\nconfig = code_gen.validate(data)\n\n# 4. Generate specific templates\ntemplates = {\"h\": single[\"h\"][1]}  # Just C header\ncode_gen.ensure_output_dir()\n\nfor ext, template_name in templates.items():\n    filename = code_gen.render_to_file(config, template_name, ext)\n    print(f\"Generated: {filename}\")\n\n# 5. Run post-generation hooks\nextra_files = generator.post_generate(\n    config, \n    code_gen.output_path, \n    set(templates.keys())\n)\nprint(f\"Extra files: {extra_files}\")\n</code></pre>"},{"location":"usage/python-api/#rendering-to-string","title":"Rendering to String","text":"<p>If you need the generated content without writing to a file:</p> <pre><code>from jinja2 import Template\n\ntemplate = code_gen.env.get_template(\"template.h.j2\")\ncontent = generator.render(config, template)\nprint(content)\n</code></pre>"},{"location":"usage/python-api/#scaffolding-new-domains","title":"Scaffolding New Domains","text":"<pre><code>from pathlib import Path\nfrom embgen.scaffold import scaffold_domain\n\n# Create a new domain\ncreated_files = scaffold_domain(\"myprotocol\", Path(\"./domains\"))\n\nfor f in created_files:\n    print(f\"Created: {f}\")\n</code></pre>"},{"location":"usage/python-api/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Generate both C header and Python from commands YAML.\"\"\"\nfrom pathlib import Path\n\nfrom embgen.discovery import discover_domains, detect_domain\nfrom embgen.generator import CodeGenerator\nfrom embgen.templates import discover_templates\n\n\ndef generate_commands(yaml_path: Path, output_dir: Path) -&gt; list[str]:\n    \"\"\"Generate all formats from a commands YAML file.\"\"\"\n\n    # Discover domains\n    domains = discover_domains()\n\n    # Set up generator\n    generator = domains[\"commands\"]\n    code_gen = CodeGenerator(generator, output_dir)\n\n    # Discover templates\n    single_templates, _ = discover_templates(generator.templates_path)\n\n    # Build template dict (all formats)\n    templates = {ext: info[1] for ext, info in single_templates.items()}\n\n    # Generate\n    return code_gen.generate_from_file(yaml_path, templates)\n\n\nif __name__ == \"__main__\":\n    files = generate_commands(\n        Path(\"commands.yml\"),\n        Path(\"generated\")\n    )\n    print(f\"Generated {len(files)} files: {files}\")\n</code></pre>"},{"location":"usage/python-api/#error-handling","title":"Error Handling","text":"<pre><code>from pydantic import ValidationError\n\ntry:\n    config = code_gen.validate(data)\nexcept RuntimeError as e:\n    print(f\"Validation failed: {e}\")\n\ntry:\n    data = code_gen.parse_yaml(Path(\"missing.yml\"))\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre>"}]}